<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>IGetHouse Word Puzzle</title>
    <meta name="description" content="Learn real-estate terms with a fast word search puzzle. Built for IGetHouse." />
    <link rel="stylesheet" href="./assets/tailwind.css" />
    <style>
      #game-scale { transform: scale(0.85); transform-origin: top center; }
      @media (max-width: 480px) { #game-scale { transform: scale(0.8); } }
      @media (max-width: 360px) { #game-scale { transform: scale(0.75); } }
      /* Ensure header logo stays small even if Tailwind is not rebuilt */
      #brand-logo { height: 48px; width: auto; object-fit: contain; display: block; }
      /* Difficulty chip hover using brand palette without Tailwind rebuild */
      .chip { background:#ffffff; border:1px solid #e5e7eb; color:#374151; transition: background-color .2s ease, color .2s ease, border-color .2s ease; }
      .chip:hover { background:#B6E3C3; color:#025940; border-color:#025940; cursor:pointer; }
      .chip:focus-visible { outline:2px solid rgba(2,89,64,0.4); outline-offset:2px; }
      /* Tip toast overlay centered */
      #tip-toast { position:fixed; left:50%; top:50%; max-width:min(90vw,520px); z-index:50; background:#025940; color:#fff; padding:14px 16px; border-radius:14px; box-shadow:0 10px 24px rgba(0,0,0,.25); opacity:0; transform:translate(-50%, -40%) scale(.98); pointer-events:none; transition:opacity .25s ease, transform .25s ease; text-align:center; }
      #tip-toast.show { opacity:1; transform:translate(-50%, -50%) scale(1); pointer-events:auto; }
      #tip-toast .close-btn { margin-left:12px; background:rgba(255,255,255,.15); color:#fff; border:0; padding:6px 10px; border-radius:8px; font-size:.85rem; }
      #tip-toast .close-btn:hover { background:rgba(255,255,255,.25); cursor:pointer; }
      /* Light green borders for grid cells and word list items */
      #grid button { border-color:#B6E3C3 !important; }
      #word-list li { border-color:#B6E3C3 !important; }
      /* Settings dialog theming */
      #settings-dialog::backdrop { background: rgba(31,41,55,0.45); }
      #settings-dialog form { border:1px solid #B6E3C3; box-shadow:0 10px 28px rgba(0,0,0,0.12); }
      #settings-dialog select { border:1px solid #B6E3C3; border-radius:0.75rem; padding:0.5rem 0.75rem; }
      #settings-dialog select:focus { outline:2px solid rgba(2,89,64,0.4); outline-offset:2px; }
      #settings-dialog input[type="checkbox"] { accent-color:#025940; width:1.125rem; height:1.125rem; }
      #settings-dialog label span { color:#025940; font-weight:600; }
      /* Prizes dialog theming */
      #prizes-dialog::backdrop { background: rgba(31,41,55,0.45); }
      .prize-badge { display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:9999px; background:#F1FBF4; color:#025940; border:1px solid #B6E3C3; font-weight:600; font-size:.9rem; }
      .prize-item { display:flex; align-items:flex-start; gap:10px; padding:10px 12px; border-radius:12px; background:#ffffff; border:1px solid #E5F3EA; }
      .prize-icon { width:28px; height:28px; border-radius:9999px; display:flex; align-items:center; justify-content:center; background:#EAF7EF; color:#025940; font-size:16px; }
      /* Light green borders for NHF and WhatsApp CTAs */
      #cta-nhf, #cta-whatsapp, #win-cta-2, #win-cta-3 { border:1px solid #B6E3C3; }
      /* Prize reminder animation */
      #prize-reminder { position:relative; border:1px solid #B6E3C3; animation: prizePulse 1.6s ease-in-out infinite, prizeGlow 2.6s ease-in-out infinite; }
      @keyframes prizeGlow { 0% { box-shadow: 0 0 0 rgba(2,89,64,0.0);} 50% { box-shadow: 0 12px 32px rgba(2,89,64,0.22);} 100% { box-shadow: 0 0 0 rgba(2,89,64,0.0);} }
      @keyframes prizePulse { 0% { transform: scale(1); border-color:#B6E3C3; } 50% { transform: scale(1.02); border-color:#8FD9B0; } 100% { transform: scale(1); border-color:#B6E3C3; } }
      #prize-reminder .prize-icon { animation: iconBounce 1.8s ease-in-out infinite; }
      @keyframes iconBounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-4px); } }
      #prize-reminder .prize-elig-badge { position:absolute; top:8px; right:10px; background:#EAF7EF; color:#025940; border:1px solid #B6E3C3; border-radius:9999px; padding:4px 10px; font-weight:700; font-size:.75rem; animation: badgeBlink 1.4s ease-in-out infinite; }
      @keyframes badgeBlink { 0%, 100% { opacity:0.6; transform: translateY(0);} 50% { opacity:1; transform: translateY(-2px);} }
      /* Selection overlay for drag path */
      .cell-hover { background:#B6E3C3 !important; }
      .cell-start { background:#9fdab3 !important; }
      /* Coach popup (round, question-like) */
      #coach-pop { position:fixed; left:50%; top:50%; transform:translate(-50%, -50%) scale(.96); width:260px; height:260px; border-radius:9999px; background:#025940; color:#ffffff; border:2px solid #B6E3C3; box-shadow:0 12px 30px rgba(0,0,0,0.18); display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; padding:18px; z-index:9999; opacity:0; pointer-events:none; transition:opacity .2s ease, transform .2s ease; }
      #coach-pop.show { opacity:1; transform:translate(-50%, -50%) scale(1); pointer-events:auto; }
      #coach-pop .qmark { font-size:48px; line-height:1; margin-bottom:8px; color:#ffffff; }
      #coach-pop .msg { font-size:14px; color:#ffffff; }
      #coach-pop .close { position:absolute; right:10px; top:10px; border:0; background:#025940; color:#ffffff; width:28px; height:28px; border-radius:9999px; cursor:pointer; }
      #coach-pop::after { content:""; position:absolute; bottom:-14px; left:50%; transform:translateX(-50%); width:0; height:0; border-left:12px solid transparent; border-right:12px solid transparent; border-top:14px solid #B6E3C3; }
    </style>
  </head>
  <body class="min-h-screen bg-brand-sand/40 text-brand-charcoal">
    <header class="sticky top-0 z-10 bg-white/80 backdrop-blur border-b border-gray-100">
      <div class="mx-auto max-w-7xl px-4 flex items-center gap-3" style="height:70px">
        <img id="brand-logo" src="./assets/logo.jpg" alt="IGetHouse" class="h-10 w-auto block shrink-0" />
        <div class="flex-1">
          <h1 class="text-lg font-semibold text-brand leading-tight">Word Puzzle</h1>
          <p class="text-xs text-gray-500 leading-tight">Learn property terms. Play daily. Share wins.</p>
        </div>
        <nav class="flex items-center gap-2">
          <button id="btn-home" class="btn-ghost focus-ring text-brand hover:bg-brand-mint/30" aria-label="Go to Home">Home</button>
          <button id="btn-settings" class="btn-ghost focus-ring text-brand hover:bg-brand-mint/30" aria-haspopup="dialog" aria-controls="settings-dialog">Settings</button>
        </nav>
      </div>
    </header>

    <main id="view-home" class="mx-auto max-w-7xl px-4 py-6 space-y-6">
      <section class="card p-5">
        <div class="flex items-center justify-between gap-4">
          <div>
            <h2 class="text-xl font-semibold text-brand">Play today‚Äôs Daily Challenge</h2>
            <p class="text-sm text-gray-600">Same puzzle for everyone. Come back daily to build your streak.</p>
          </div>
          <button id="btn-daily" class="btn-primary focus-ring">Play Daily</button>
        </div>
      </section>

      <section class="grid md:grid-cols-3 gap-4" aria-labelledby="categories-title">
        <h2 id="categories-title" class="sr-only">Categories</h2>
        <div id="categories-grid" class="md:col-span-3 grid sm:grid-cols-2 lg:grid-cols-3 gap-4"></div>
      </section>
    </main>

    <main id="view-game" class="hidden mx-auto max-w-7xl px-4 py-6">
      <div id="game-scale">
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-4">
          <aside class="lg:col-span-3 card p-4 flex flex-col gap-4" aria-labelledby="word-list-title">
            <div class="flex items-center justify-between">
              <h2 id="word-list-title" class="font-semibold text-brand">Words</h2>
              <div class="text-sm text-gray-500"><span id="progress-count">0</span>/<span id="progress-total">0</span></div>
            </div>
            <ul id="word-list" class="grid grid-cols-2 gap-2 text-sm"></ul>
            <div class="text-sm text-gray-700 font-semibold">
              <span>Category:</span>
              <span id="category-name" class="text-brand font-semibold">‚Äî</span>
            </div>
            <div class="flex items-center gap-2 text-xs text-gray-600">
              <span class="font-medium">Difficulty:</span>
              <span id="difficulty-badge" class="px-2 py-0.5 rounded-full border border-gray-200 text-xs text-brand bg-white">Medium</span>
            </div>
            <div class="mt-1">
              <button id="btn-reveal" class="btn-ghost focus-ring text-brand hover:bg-brand-mint/30 hidden" title="Reveal all words">Reveal All</button>
            </div>
            <div class="mt-auto flex items-center gap-2">
              <button id="btn-back" class="btn-primary focus-ring" aria-label="Back to categories">Back</button>
              <button id="btn-hint" class="btn-primary focus-ring" aria-live="polite">Hint (2)</button>
              <button id="btn-restart" class="btn-primary focus-ring">Restart</button>
            </div>
            <div class="text-xs text-brand font-semibold">Tips appear as you play.</div>
            <div id="tips-panel" class="text-sm font-semibold"></div>
          </aside>

          <section class="lg:col-span-6 card p-4 flex flex-col gap-3" aria-labelledby="grid-title">
            <div class="flex items-center justify-between">
              <h2 id="grid-title" class="font-semibold text-brand">Find all the words</h2>
              <div class="flex items-center gap-3 text-sm">
                <div>Time: <span id="timer">00:00</span></div>
                <div>Score: <span id="score">0</span></div>
              </div>
            </div>
            <div id="grid" role="grid" aria-label="Puzzle grid" class="select-none touch-none"></div>
            <div class="text-xs text-brand font-semibold">Use mouse/touch to drag. Keyboard: hold <kbd class="kbd">Shift</kbd> + arrows, <kbd class="kbd">Enter</kbd> to confirm.</div>
          </section>

          <aside class="lg:col-span-3 hidden lg:flex lg:flex-col gap-3">
            <div class="card p-4">
              <h3 class="font-semibold mb-2 text-brand">Explore IGetHouse</h3>
              <div class="grid gap-2">
                <a class="btn-primary focus-ring" href="#" id="cta-listings" target="_blank" rel="noopener">Visit IGetHouse</a>
                <a class="btn-ghost focus-ring text-brand hover:bg-brand-mint/30" href="#" id="cta-nhf" target="_blank" rel="noopener">Check Your NHF Options</a>
                <a class="btn-ghost focus-ring text-brand hover:bg-brand-mint/30" href="#" id="cta-whatsapp" target="_blank" rel="noopener">Chat on WhatsApp<br/>with Biola Salami</a>
              </div>
            </div>
            <div id="prize-reminder" class="card p-4 bg-white">
              <div class="prize-elig-badge">Finish under 5 min</div>
              <div class="flex items-start gap-3">
                <div class="prize-icon">‚è±Ô∏è</div>
                <div class="flex-1">
                  <div class="font-semibold text-brand">Win a Prize on Hard!</div>
                  <div class="text-sm text-gray-600">Finish Hard mode within 5 minutes to win a prize from IGetHouse. Give it a try!</div>
                </div>
              </div>
            </div>
          </aside>
        </div>
      </div>
    </main>

    <dialog id="results-modal" class="rounded-2xl p-0 w-[min(90vw,420px)]">
      <form method="dialog" class="card p-4">
        <h2 class="text-xl font-semibold text-brand">üéâ You did it!</h2>
        <p class="text-sm text-gray-600">Time: <span id="final-time">00:00</span> ‚Ä¢ Score: <span id="final-score">0</span> ‚Ä¢ Streak: <span id="final-streak">0</span></p>
        <div class="mt-4 grid gap-2">
          <button id="win-cta-1" class="btn-primary">Visit IGetHouse</button>
          <button id="win-cta-2" class="btn-ghost text-brand hover:bg-brand-mint/30">Check Your NHF Options</button>
          <button id="win-cta-3" class="btn-ghost text-brand hover:bg-brand-mint/30">Chat on WhatsApp<br/>with Biola Salami</button>
        </div>
        <div class="mt-3 flex items-center gap-2">
          <button id="btn-share-wa" class="btn-ghost text-brand hover:bg-brand-mint/30">Share on WhatsApp</button>
          <button id="btn-share-x" class="btn-ghost text-brand hover:bg-brand-mint/30">Share on X</button>
          <button id="btn-play-again" value="cancel" class="btn-ghost text-brand hover:bg-brand-mint/30 ml-auto">Play Again</button>
        </div>
      </form>
    </dialog>

    <dialog id="hard-results-modal" class="rounded-2xl p-0 w-[min(92vw,520px)]">
      <form method="dialog" class="card p-0 overflow-hidden">
        <div class="bg-brand text-white px-6 py-5">
          <h2 class="text-xl font-semibold">üéØ Hard Mode Complete!</h2>
          <p class="text-sm opacity-90">You pushed your limits on Hard.</p>
        </div>
        <div class="p-5 grid gap-3">
          <div class="text-sm text-gray-600">Time: <span id="hard-final-time">00:00</span> ‚Ä¢ Score: <span id="hard-final-score">0</span></div>
          <div id="hard-eligibility" class="text-brand font-semibold"></div>
          <div class="card p-3 bg-white border border-gray-100 rounded-xl">
            <div class="text-sm text-gray-600">Your prize</div>
            <div id="hard-prize" class="text-lg font-semibold text-brand">‚Äî</div>
          </div>
          <div class="grid sm:grid-cols-2 gap-2 mt-2">
            <button id="hard-claim-wa" class="btn-ghost focus-ring text-brand hover:bg-brand-mint/30" type="button">Claim via WhatsApp</button>
            <button id="hard-btn-play-again" value="cancel" class="btn-primary focus-ring">Play Again</button>
          </div>
        </div>
      </form>
    </dialog>

    <dialog id="prizes-dialog" class="rounded-2xl p-0 w-[min(92vw,560px)]">
      <form method="dialog" class="card p-0 overflow-hidden">
        <div class="bg-gradient-to-r from-brand via-brand to-emerald-600 text-white px-6 py-5">
          <div class="flex items-center gap-3">
            <div class="prize-icon" style="background: rgba(255,255,255,.2); color:#fff;">üèÜ</div>
            <div>
              <h2 class="text-xl font-bold leading-tight">Play Hard to Win Amazing Prizes</h2>
              <p class="text-sm opacity-90">Push your skills on Hard mode for a chance to win.</p>
            </div>
          </div>
          <div class="mt-3">
            <span class="prize-badge">Hard Mode Rewards</span>
          </div>
        </div>
        <div class="p-5 grid gap-3 bg-white">
          <div class="prize-item">
            <div class="prize-icon">üé®</div>
            <div class="text-brand font-semibold">Personalised Home D√©cor Moodboard</div>
          </div>
          <div class="prize-item">
            <div class="prize-icon">üè°</div>
            <div class="text-brand font-semibold">'My Dream Home'</div>
          </div>
          <div class="prize-item">
            <div class="prize-icon">üì¶</div>
            <div class="text-brand font-semibold">Property Investment Starter Kit (Digital Pack + ‚Ç¶50k Voucher)</div>
          </div>
          <div class="prize-item">
            <div class="prize-icon">üß≠</div>
            <div class="text-brand font-semibold">1-on-1 Real Estate Coaching Session</div>
          </div>
          <div class="prize-item">
            <div class="prize-icon">üì∏</div>
            <div class="text-brand font-semibold">Free Photoshoot of Your New Home purchased on our platform</div>
          </div>
          <div class="mt-2 grid sm:grid-cols-2 gap-2">
            <button id="btn-prize-hard" class="btn-primary focus-ring">Play Hard</button>
            <button id="btn-prize-easy" value="cancel" class="btn-ghost focus-ring text-brand hover:bg-brand-mint/30">Continue with Easy</button>
          </div>
        </div>
      </form>
    </dialog>
    <dialog id="settings-dialog" class="rounded-2xl p-0 w-[min(92vw,480px)]">
      <form method="dialog" class="card p-5 space-y-4">
        <h2 class="text-lg font-semibold text-brand">Settings</h2>
        <div class="grid gap-3">
          <label class="flex items-center justify-between gap-3">
            <span>Difficulty</span>
            <select id="difficulty" class="border rounded-xl px-3 py-2">
              <option value="easy">Easy</option>
              <option value="medium">Medium</option>
              <option value="hard">Hard</option>
            </select>
          </label>
          <label class="flex items-center justify-between gap-3">
            <span>Timer</span>
            <input id="timer-enabled" type="checkbox" class="size-5" checked />
          </label>
          <label class="flex items-center justify-between gap-3">
            <span>Sound</span>
            <input id="sound-enabled" type="checkbox" class="size-5" />
          </label>
        </div>
        <div class="flex gap-2 justify-end">
          <button value="cancel" class="btn-primary">Close</button>
        </div>
      </form>
    </dialog>

    <div aria-live="polite" aria-atomic="true" class="sr-only" id="live-region"></div>
    <div id="tip-toast" role="dialog" aria-modal="true" aria-label="Game tip" tabindex="-1"></div>
    <div id="coach-pop" role="dialog" aria-modal="true" aria-label="Coach message">
      <button class="close" id="coach-close" aria-label="Close">√ó</button>
      <div class="qmark">‚ùì</div>
      <div class="msg" id="coach-msg"></div>
    </div>

    <script>
      // Words data (no fetch)
      const Words = {
        propertyTypes: [
          "Apartment", "Bungalow", "Duplex", "Penthouse", "Maisonette", "Studio", "Terrace", "Semi-Detached", "Detached", "Tenement", "Self-Contain", "Mini-Flat", "Chalet", "Condo"
        ],
        homeInteriorDecor: [
          "Kitchen", "Sofa", "Ceiling", "Lighting", "Paint", "Rug", "Wardrobe", "Curtain", "Tiles", "Wallpaper", "Island", "Backsplash", "Faucet", "Chandelier", "Cushion"
        ],
        mortgageFinance: [
          "Mortgage", "Equity", "Interest", "NHF", "Collateral", "Appraisal", "Downpayment", "Amortization", "Lender", "Refinancing", "PMI", "Tenor", "Offer", "Valuation", "Underwriting"
        ],
        legalDocumentation: [
          "Deed", "Title", "Survey", "C of O", "Consent", "Agreement", "Covenant", "Easement", "Lease", "Tenancy", "Stamp", "Search", "Probate", "Indenture", "Encumbrance"
        ],
        constructionMaterials: [
          "Concrete", "Rebar", "Foundation", "Beam", "Plaster", "Roofing", "Asphalt", "Aggregate", "Grout", "Block", "Formwork", "Column", "Screed", "Primer"
        ],
        maintenanceUtilities: [
          "Generator", "Inverter", "Solar", "Meter", "Borehole", "Sewage", "Water", "Waste", "HVAC", "Filter", "Breaker", "Fuse", "Pump", "Gutter", "Pressure"
        ],
        stakeholdersRoles: [
          "Realtor", "Broker", "Surveyor", "Valuer", "Architect", "Engineer", "Builder", "Developer", "Landlord", "Tenant", "Caretaker", "Inspector", "Notary"
        ],
        locationsNigeria: [
          "Lagos", "Abuja", "Port Harcourt", "Ibadan", "Kano", "Enugu", "Benin", "Kaduna", "Abeokuta", "Lekki", "Yaba", "Ikeja", "Ajah", "Ikoyi", "Surulere", "Gbagada", "Owerri", "Uyo", "Warri"
        ],
        investmentMetrics: [
          "ROI", "Yield", "Cashflow", "Vacancy", "Appreciation", "Rental", "Capital", "Leverage", "Portfolio", "Risk", "Equity", "Diversify", "Depreciation", "Net", "Gross"
        ],
        smartHomeTech: [
          "Sensor", "Camera", "Doorbell", "Thermostat", "Hub", "Automation", "WiFi", "Router", "Alarm", "Access", "Intercom", "Lock", "Lighting", "Smart", "Panel"
        ]
      };

      // Category display names
      const CategoryNames = {
        propertyTypes: 'Property Types',
        homeInteriorDecor: 'Home Interior & Decor',
        mortgageFinance: 'Mortgage & Finance',
        legalDocumentation: 'Legal & Documentation',
        constructionMaterials: 'Construction & Materials',
        maintenanceUtilities: 'Maintenance & Utilities',
        stakeholdersRoles: 'Stakeholders & Roles',
        locationsNigeria: 'Locations (Nigeria)',
        investmentMetrics: 'Investment & Metrics',
        smartHomeTech: 'Smart Home & Tech'
      };

      // Micro tips by category (fallback to general)
      const Tips = {
        general: [
          'You may qualify for NHF; check options at the FMBN site.',
          'Compare neighborhoods on IGetHouse to find your fit.',
          'Back-to-back selections under 15s boost combo and score.'
        ],
        mortgageFinance: [
          'NHF can reduce interest vs. commercial mortgages.',
          'Bigger down payments often lower your monthly cost.'
        ],
        legalDocumentation: [
          'Always verify title (C of O or equivalent) before payment.',
          'Use a survey plan to confirm boundaries and encumbrances.'
        ],
        propertyTypes: [
          'Semi-detached homes share one wall; detached share none.',
          'Terraced houses are aligned in a row with shared walls.'
        ]
      };

      // Coach messages (gamified encouragement)
      const CoachMessages = [
        'Try scanning the grid slowly‚Äîstart from the corners.',
        'Look for unique letters like Q, X or Z and trace lines.',
        'Short words are quickest wins. Get a streak going!',
        'Drag in straight lines: horizontal, vertical, or diagonal.',
        'Spot repeated letters and connect the dots.',
        'Breathe. Re-focus. The next word is right there!',
        'Hint: start with a category term you know well.'
      ];
      const pickCoachMessage = (rand) => CoachMessages[Math.floor((rand ? rand() : Math.random()) * CoachMessages.length)];
      const isCoachVisible = () => {
        const box = document.getElementById('coach-pop');
        return !!box && box.classList.contains('show');
      };
      const showCoach = (text) => {
        const box = document.getElementById('coach-pop');
        const msg = document.getElementById('coach-msg');
        if (!box || !msg) return;
        msg.textContent = text;
        try { document.body.appendChild(box); } catch {}
        box.classList.add('show');
        box.style.opacity = '1';
        box.style.pointerEvents = 'auto';
        box.style.transform = 'translate(-50%, -50%) scale(1)';
        const btn = document.getElementById('coach-close');
        if (btn) btn.onclick = hideCoach;
      };
      const hideCoach = () => {
        const box = document.getElementById('coach-pop');
        if (!box) return;
        box.classList.remove('show');
        box.style.opacity = '0';
        box.style.pointerEvents = 'none';
        box.style.transform = 'translate(-50%, -50%) scale(.96)';
      };
      const clearCoachTimer = (state) => { if (state && state.coachTimer) { clearTimeout(state.coachTimer); state.coachTimer = null; } if (state && state.coachFallbackTimer) { clearTimeout(state.coachFallbackTimer); state.coachFallbackTimer = null; } };
      const triggerCoachOnLaunch = (state) => {
        // No-op: initial popup on game load is disabled
        return;
      };
      const scheduleCoachInactivity = (state) => {
        clearCoachTimer(state);
        // If popup is currently visible, do not queue another
        if (isCoachVisible()) return;
        state.coachTimer = setTimeout(() => {
          // Only show if still no word and popup not visible
          if (state && state.found && state.found.size === 0 && !isCoachVisible()) {
            showCoach(pickCoachMessage(state.rand));
          }
        }, 20000);
      };
      const wireCoachClose = () => {
        const btn = document.getElementById('coach-close');
        if (btn) btn.onclick = () => { hideCoach(); if (typeof current !== 'undefined' && current && current.found && current.found.size === 0) scheduleCoachInactivity(current); };
      };

      const getTipsFor = (categoryKey) => Tips[categoryKey] || Tips.general;
      const showTip = (text) => {
        const toast = document.getElementById('tip-toast');
        if (!toast) return;
        toast.innerHTML = `<span>${text}</span><button class="close-btn" id="tip-close" aria-label="Close tip" title="Close">√ó</button>`;
        toast.classList.add('show');
        const closer = document.getElementById('tip-close');
        const hide = () => { toast.classList.remove('show'); };
        if (closer) closer.onclick = hide;
      };

      // Constants
      const DifficultyConfig = {
        easy: { gridSize: 8, wordsMin: 8, wordsMax: 10, allowDiagonals: false, allowBackwardsRatio: 0 },
        medium: { gridSize: 12, wordsMin: 12, wordsMax: 14, allowDiagonals: true, allowBackwardsRatio: 0.3 },
        hard: { gridSize: 15, wordsMin: 14, wordsMax: 16, allowDiagonals: true, allowBackwardsRatio: 0.5 }
      };
      const BrandLinks = {
        listingsLagos: 'https://www.igethouse.ng/',
        nhfInfo: 'https://www.fmbn.gov.ng/',
        whatsapp: 'https://wa.me/2349165226722?text=Hi%20Biola%20Salami%2C%20I%20just%20finished%20the%20word%20puzzle%20on%20IGetHouse!'
      };

      // Hard mode prizes
      const HardPrizes = [
        'Personalised Home D√©cor Moodboard',
        "'My Dream Home'",
        'Property Investment Starter Kit (Digital Pack + ‚Ç¶50k Voucher)',
        '1-on-1 Real Estate Coaching Session',
        'Free Photoshoot of Your New Home purchased on our platform'
      ];

      // Utils
      const normalizeWord = (w) => w.replace(/[^A-Za-z0-9]/g, '').toUpperCase();
      const shuffleInPlace = (arr, rand) => { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(rand() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; };
      const pickRandom = (arr, rand) => arr[Math.floor(rand() * arr.length)];
      const timeToMMSS = (sec) => { const m = Math.floor(sec / 60).toString().padStart(2, '0'); const s = Math.floor(sec % 60).toString().padStart(2, '0'); return `${m}:${s}`; };
      const todayYYYYMMDD = () => { const d = new Date(); const y = d.getFullYear(); const m = String(d.getMonth() + 1).padStart(2, '0'); const day = String(d.getDate()).toString().padStart(2, '0'); return `${y}${m}${day}`; };
      const fnv1a32Hex = (text) => { let hash = 0x811c9dc5; for (let i = 0; i < text.length; i++) { hash ^= text.charCodeAt(i); hash = (hash >>> 0) * 0x01000193; hash >>>= 0; } return (hash >>> 0).toString(16).padStart(8, '0'); };
      const sha256Hex = async (text) => { try { if (typeof crypto !== 'undefined' && crypto.subtle && location.protocol !== 'file:') { const enc = new TextEncoder(); const data = enc.encode(text); const hash = await crypto.subtle.digest('SHA-256', data); const bytes = Array.from(new Uint8Array(hash)); return bytes.map((b) => b.toString(16).padStart(2, '0')).join(''); } } catch {} return fnv1a32Hex(text); };
      const hexToUint32 = (hex) => { const slice = hex.slice(0, 8); return parseInt(slice, 16) >>> 0; };
      const createRng = (seed) => { let state = seed >>> 0; if (state === 0) state = 0x9e3779b9; return () => { state ^= state << 13; state ^= state >>> 17; state ^= state << 5; return (state >>> 0) / 0xffffffff; }; };
      const liveAnnounce = (msg) => { const el = document.getElementById('live-region'); if (!el) return; el.textContent = ''; setTimeout(() => (el.textContent = msg), 10); };

      // Sound manager (Web Audio) honoring settings
      let __audioCtx = null;
      const getAudio = () => {
        if (!__audioCtx) {
          const Ctx = window.AudioContext || window.webkitAudioContext;
          if (Ctx) __audioCtx = new Ctx();
        }
        return __audioCtx;
      };
      const resumeAudioOnGesture = () => {
        const ctx = getAudio();
        if (ctx && ctx.state === 'suspended') ctx.resume().catch(() => {});
      };
      document.addEventListener('click', resumeAudioOnGesture, { once: true });
      const beep = (freq, duration, type = 'sine', volume = 0.05) => {
        const ctx = getAudio(); if (!ctx) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type; osc.frequency.value = freq; gain.gain.value = volume;
        osc.connect(gain).connect(ctx.destination);
        const now = ctx.currentTime;
        osc.start(now);
        osc.stop(now + duration);
      };
      const Sound = {
        click: () => { if (!state.soundEnabled) return; beep(600, 0.04, 'square', 0.03); },
        success: () => { if (!state.soundEnabled) return; beep(880, 0.08, 'sine', 0.05); setTimeout(() => beep(660, 0.06, 'sine', 0.04), 80); },
        win: () => { if (!state.soundEnabled) return; [523,659,784].forEach((f,i)=> setTimeout(()=>beep(f,0.12,'triangle',0.06), i*140)); }
      };

      // UI
      const loadCategories = async (onSelect) => {
        const grid = document.getElementById('categories-grid');
        grid.innerHTML = '';
        const Categories = [
          { key: 'propertyTypes', name: 'Property Types', icon: 'üè¢', desc: 'Apartment, Duplex, Penthouse, ...' },
          { key: 'homeInteriorDecor', name: 'Home Interior & Decor', icon: 'üõãÔ∏è', desc: 'Kitchen, Sofa, Lighting, ...' },
          { key: 'mortgageFinance', name: 'Mortgage & Finance', icon: 'üí∏', desc: 'Mortgage, Equity, Interest, ...' },
          { key: 'legalDocumentation', name: 'Legal & Documentation', icon: '‚öñÔ∏è', desc: 'Deed, Title, Survey, ...' },
          { key: 'constructionMaterials', name: 'Construction & Materials', icon: 'üèóÔ∏è', desc: 'Concrete, Rebar, Beam, ...' },
          { key: 'maintenanceUtilities', name: 'Maintenance & Utilities', icon: 'üîß', desc: 'Generator, Inverter, Solar, ...' },
          { key: 'stakeholdersRoles', name: 'Stakeholders & Roles', icon: 'üë∑', desc: 'Realtor, Surveyor, Architect, ...' },
          { key: 'locationsNigeria', name: 'Locations (Nigeria)', icon: 'üìç', desc: 'Lagos, Abuja, Ibadan, ...' },
          { key: 'investmentMetrics', name: 'Investment & Metrics', icon: 'üìà', desc: 'ROI, Yield, Cashflow, ...' },
          { key: 'smartHomeTech', name: 'Smart Home & Tech', icon: 'üè†', desc: 'Sensor, Camera, Hub, ...' }
        ];
        for (const c of Categories) {
          const card = document.createElement('button');
          card.className = 'card p-4 text-left hover:shadow-md transition-shadow focus-ring';
          card.setAttribute('aria-label', `${c.name} category`);
          card.innerHTML = `
            <div class="flex items-start gap-3">
              <div class="text-2xl">${c.icon}</div>
              <div class="flex-1">
                <div class="font-semibold">${c.name}</div>
                <div class="text-sm text-gray-600">${c.desc}</div>
              </div>
            </div>
            <div class="mt-3 flex items-center gap-2 text-xs text-gray-500">
              <button type="button" data-diff="easy" class="px-2 py-0.5 rounded-full chip">Easy</button>
               <button type="button" data-diff="medium" class="px-2 py-0.5 rounded-full chip">Medium</button>
               <button type="button" data-diff="hard" class="px-2 py-0.5 rounded-full chip">Hard</button>
            </div>
          `;
          card.addEventListener('click', () => onSelect(c.key));
          grid.appendChild(card);
          // Make difficulty chips interactive
          const chips = card.querySelectorAll('[data-diff]');
          chips.forEach((btn) => {
            btn.addEventListener('click', async (e) => {
              e.stopPropagation();
              const diff = btn.getAttribute('data-diff');
              // If Easy is chosen, show prizes dialog first
              if (diff === 'easy') {
                try { state.difficulty = 'easy'; if (typeof difficultySelect !== 'undefined') difficultySelect.value = 'easy'; } catch {}
                if (typeof openPrizesDialog === 'function') openPrizesDialog({ categoryKey: c.key, startOnChoice: true });
                return;
              }
              // Otherwise proceed immediately
              try { state.difficulty = diff; if (typeof difficultySelect !== 'undefined') difficultySelect.value = diff; } catch {}
              showGame();
              await startQuickPlay(c.key);
            });
          });
        }
        const listings = document.getElementById('cta-listings');
        const nhf = document.getElementById('cta-nhf');
        const wa = document.getElementById('cta-whatsapp');
        if (listings) listings.href = BrandLinks.listingsLagos;
        if (nhf) nhf.href = BrandLinks.nhfInfo;
        if (wa) wa.href = BrandLinks.whatsapp;
      };

      // Game logic
      const sampleWordsForDifficulty = (allWords, difficultyKey, rand) => {
        const cfg = DifficultyConfig[difficultyKey];
        const count = cfg.wordsMin + Math.floor(rand() * (cfg.wordsMax - cfg.wordsMin + 1));
        // Filter out words that cannot fit the grid
        const filtered = allWords.filter((w) => normalizeWord(w).length <= cfg.gridSize);
        const pool = [...filtered];
        shuffleInPlace(pool, rand);
        return pool.slice(0, count);
      };

      const getAllowedDirections = (difficultyKey) => {
        if (difficultyKey === 'easy') return [ {dx:1,dy:0}, {dx:0,dy:1} ];
        if (difficultyKey === 'medium') return [ {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}, {dx:1,dy:1}, {dx:1,dy:-1} ];
        return [ {dx:1,dy:0}, {dx:-1,dy:0}, {dx:0,dy:1}, {dx:0,dy:-1}, {dx:1,dy:1}, {dx:-1,dy:-1}, {dx:1,dy:-1}, {dx:-1,dy:1} ];
      };

      const tryPlaceWord = (grid, word, rand, cfg, allowedDirs) => {
        const size = grid.length;
        const letters = word.split('');
        const maxAttempts = 300;
        // Build a rotated direction cycle to encourage distribution
        const dirCycle = [...allowedDirs];
        shuffleInPlace(dirCycle, rand);

        // Helper: bounded random start respecting direction and word length
        const genStart = (dir) => {
          const len = letters.length;
          const xMin = dir.dx === 1 ? 0 : dir.dx === -1 ? len - 1 : 0;
          const xMax = dir.dx === 1 ? size - len : dir.dx === -1 ? size - 1 : size - 1;
          const yMin = dir.dy === 1 ? 0 : dir.dy === -1 ? len - 1 : 0;
          const yMax = dir.dy === 1 ? size - len : dir.dy === -1 ? size - 1 : size - 1;
          const sx = xMin + Math.floor(rand() * (Math.max(0, xMax - xMin + 1)));
          const sy = yMin + Math.floor(rand() * (Math.max(0, yMax - yMin + 1)));
          return { sx, sy };
        };

        for (let attempt = 0; attempt < maxAttempts; attempt++) {
          const backwards = rand() < cfg.allowBackwardsRatio;
          const useLetters = backwards ? [...letters].reverse() : letters;
          const dir = dirCycle[attempt % dirCycle.length];
          const { sx, sy } = genStart(dir);

          let fits = true;
          for (let i = 0; i < useLetters.length; i++) {
            const x = sx + dir.dx * i;
            const y = sy + dir.dy * i;
            if (x < 0 || x >= size || y < 0 || y >= size) { fits = false; break; }
            const cell = grid[y][x];
            if (cell.letter && cell.letter !== useLetters[i]) { fits = false; break; }
          }
          if (!fits) continue;

          for (let i = 0; i < useLetters.length; i++) {
            const x = sx + dir.dx * i;
            const y = sy + dir.dy * i;
            grid[y][x].letter = useLetters[i];
            grid[y][x].wordIds.push(word);
          }
          return { placed: true, positions: Array.from({length: useLetters.length}, (_, i) => ({ x: sx + dir.dx * i, y: sy + dir.dy * i })) };
        }
        return { placed: false };
      };

      const fillRandomLetters = (grid, rand) => {
        const alphabet = 'EEEEEEEEEEEEEEEEEEEEETAOINSRHLDCUMFPGWYBVKXJQZ';
        for (let y = 0; y < grid.length; y++) {
          for (let x = 0; x < grid.length; x++) {
            if (!grid[y][x].letter) {
              grid[y][x].letter = alphabet[Math.floor(rand() * alphabet.length)];
            }
          }
        }
      };

      const buildPuzzle = (wordsRaw, difficultyKey, rand) => {
        const cfg = DifficultyConfig[difficultyKey];
        const size = cfg.gridSize;
        const grid = Array.from({ length: size }, () => Array.from({ length: size }, () => ({ letter: '', wordIds: [], locked: false })));
        const allowedDirs = getAllowedDirections(difficultyKey);
        // Use only words that can fit
        const words = wordsRaw.map(normalizeWord).filter((w) => w.length <= size).sort((a,b) => b.length - a.length);
        const wordPlacements = new Map();
        for (const w of words) {
          const result = tryPlaceWord(grid, w, rand, cfg, allowedDirs);
          if (!result.placed) continue;
          wordPlacements.set(w, result.positions);
        }
        fillRandomLetters(grid, rand);
        return { grid, wordPlacements };
      };

      const elements = {
        grid: () => document.getElementById('grid'),
        wordList: () => document.getElementById('word-list'),
        progressCount: () => document.getElementById('progress-count'),
        progressTotal: () => document.getElementById('progress-total'),
        timer: () => document.getElementById('timer'),
        score: () => document.getElementById('score'),
        hintBtn: () => document.getElementById('btn-hint'),
        restartBtn: () => document.getElementById('btn-restart'),
        resultsModal: () => document.getElementById('results-modal'),
        finalTime: () => document.getElementById('final-time'),
        finalScore: () => document.getElementById('final-score'),
        finalStreak: () => document.getElementById('final-streak')
      };

      const renderPuzzle = (puzzle) => {
        const gridEl = elements.grid();
        const size = puzzle.grid.length;
        gridEl.style.display = 'grid';
        gridEl.style.gridTemplateColumns = `repeat(${size}, minmax(0,1fr))`;
        gridEl.style.gap = '4px';
        gridEl.innerHTML = '';
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const btn = document.createElement('button');
            btn.className = 'aspect-square rounded-lg border border-gray-200 bg-white text-sm font-semibold select-none focus-ring';
            btn.dataset.x = String(x);
            btn.dataset.y = String(y);
            btn.textContent = puzzle.grid[y][x].letter;
            gridEl.appendChild(btn);
          }
        }
      };

      const renderWordList = (words, foundSet) => {
        const list = elements.wordList();
        list.innerHTML = '';
        for (const w of words) {
          const li = document.createElement('li');
          const normalized = normalizeWord(w);
          li.textContent = w;
          li.className = 'px-2 py-1 rounded-lg border border-gray-200 bg-white';
          if (foundSet.has(normalized)) li.classList.add('line-through', 'opacity-60');
          list.appendChild(li);
        }
      };

      const attachSelectionHandlers = (state) => {
        const gridEl = elements.grid();
        let selecting = false;
        let start = null;
        let hoveredCells = [];
        const clearHover = () => { for (const el of hoveredCells) { el.classList.remove('cell-hover'); el.classList.remove('cell-start'); } hoveredCells = []; };
        const getCell = (x, y) => gridEl.querySelector(`button[data-x="${x}"][data-y="${y}"]`);
        const normalizeDir = (dx, dy) => { if (dx === 0 && dy === 0) return { dx: 0, dy: 0 }; const ndx = dx === 0 ? 0 : dx > 0 ? 1 : -1; const ndy = dy === 0 ? 0 : dy > 0 ? 1 : -1; return { dx: ndx, dy: ndy }; };
        const computePath = (sx, sy, ex, ey) => { const dir = normalizeDir(ex - sx, ey - sy); if (dir.dx === 0 && dir.dy === 0) return []; const path = []; let x = sx, y = sy; while (x !== ex || y !== ey) { x += dir.dx; y += dir.dy; path.push({ x, y }); if (path.length > 50) break; } return [{ x: sx, y: sy }, ...path]; };
        const onDown = (e) => { const target = e.target.closest('button[data-x]'); if (!target) return; selecting = true; start = { x: Number(target.dataset.x), y: Number(target.dataset.y) }; clearHover(); if (!target.classList.contains('cell-found')) { target.classList.add('cell-start'); } hoveredCells.push(target); Sound.click(); scheduleCoachInactivity(state); };
        const onMove = (e) => { if (!selecting || !start) return; const target = e.target.closest('button[data-x]'); if (!target) return; const end = { x: Number(target.dataset.x), y: Number(target.dataset.y) }; clearHover(); const path = computePath(start.x, start.y, end.x, end.y); for (const p of path) { const cell = getCell(p.x, p.y); if (cell && !cell.classList.contains('cell-found')) { if (p.x === start.x && p.y === start.y) { cell.classList.add('cell-start'); } else { cell.classList.add('cell-hover'); } hoveredCells.push(cell); } } scheduleCoachInactivity(state); };
        const onUp = () => {
          if (!selecting || !start) return; selecting = false;
          const letters = hoveredCells.map((el) => el.textContent).join('');
          const reversed = letters.split('').reverse().join('');
          let matchedKey = null;
          for (const key of Object.keys(state.wordPlacements)) { const word = key; if (word === letters || word === reversed) { matchedKey = word; break; } }
          if (matchedKey && !state.found.has(matchedKey)) {
            state.found.add(matchedKey);
            for (const el of hoveredCells) { el.classList.add('bg-brand','text-white','cell-found'); el.classList.remove('cell-hover'); el.classList.remove('cell-start'); }
            elements.progressCount().textContent = String(state.found.size);
            liveAnnounce('Word found');
            // Once a word is found, hide and stop coach prompts
            hideCoach();
            clearCoachTimer(state);
            updateScoreOnWord(state);
            renderWordList(state.originalWords, state.foundView);
            if (state.found.size % 3 === 0) { const arr = getTipsFor(state.categoryKey); if (arr.length) { state.lastTipIndex = (state.lastTipIndex + 1) % arr.length; showTip(arr[state.lastTipIndex]); } }
            Sound.success();
            checkCompletion(state);
          }
          clearHover(); start = null;
          // Re-arm timer after interaction if popup is not visible
          scheduleCoachInactivity(state);
        };
        gridEl.addEventListener('mousedown', onDown);
        gridEl.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
        gridEl.addEventListener('touchstart', (e) => { e.preventDefault(); onDown(e.touches[0]); }, { passive: false });
        gridEl.addEventListener('touchmove', (e) => { e.preventDefault(); onMove(e.touches[0]); }, { passive: false });
        gridEl.addEventListener('touchend', (e) => { e.preventDefault(); onUp(); }, { passive: false });
      };

      const startTimer = (state) => {
        state.timerStart = performance.now();
        if (state.timerInterval) clearInterval(state.timerInterval);
        state.timerInterval = setInterval(() => {
          const secs = Math.floor((performance.now() - state.timerStart) / 1000);
          elements.timer().textContent = timeToMMSS(secs);
        }, 250);
      };
      const stopTimer = (state) => { if (state.timerInterval) clearInterval(state.timerInterval); state.timerInterval = null; const secs = Math.floor((performance.now() - state.timerStart) / 1000); return secs; };
      const stopTimerIfRunning = (state) => { if (state && state.timerInterval) { clearInterval(state.timerInterval); state.timerInterval = null; } };
      const updateScoreOnWord = (state) => { const diffMult = state.difficulty === 'easy' ? 1.0 : state.difficulty === 'medium' ? 1.3 : 1.6; const now = performance.now(); const secondsSinceLast = state.lastWordAt ? (now - state.lastWordAt) / 1000 : 999; state.lastWordAt = now; let delta = Math.floor(100 * diffMult); const timeBonus = Math.max(0, 50 - Math.floor(secondsSinceLast)); delta += timeBonus; if (secondsSinceLast < 15) state.combo += 10; else state.combo = 0; delta += state.combo; state.score += delta; elements.score().textContent = String(state.score); };
      const checkCompletion = (state) => {
        if (state.found.size >= state.targetWordCount) {
          const secs = stopTimer(state);
          let final = state.score;
          if (!state.timerEnabled) final = Math.floor(final * 0.9);
          final = Math.floor(final * (1 - 0.15 * state.hintsUsed));
          // Branch: Hard mode gets special prize modal
          if (state.difficulty === 'hard') {
            const hardTimeEl = document.getElementById('hard-final-time');
            const hardScoreEl = document.getElementById('hard-final-score');
            const hardEligEl = document.getElementById('hard-eligibility');
            const hardPrizeEl = document.getElementById('hard-prize');
            const hardModal = document.getElementById('hard-results-modal');
            if (hardTimeEl) hardTimeEl.textContent = timeToMMSS(secs);
            if (hardScoreEl) hardScoreEl.textContent = String(final);
            const eligible = secs <= 300; // 5 minutes
            if (hardEligEl) hardEligEl.textContent = eligible ? '‚úÖ Eligible: Completed under 5 minutes.' : '‚ùå Not eligible: Complete within 5 minutes to claim prizes.';
            // Shuffle prizes and pick one
            const shuffled = [...HardPrizes];
            shuffleInPlace(shuffled, () => Math.random());
            const picked = shuffled[0] || HardPrizes[0];
            if (hardPrizeEl) hardPrizeEl.textContent = eligible ? picked : 'Play again faster to unlock a prize.';
            Sound.win();
            if (hardModal && hardModal.showModal) hardModal.showModal();
            const claimBtn = document.getElementById('hard-claim-wa');
            if (claimBtn) claimBtn.onclick = () => { window.open(BrandLinks.whatsapp, '_blank'); };
            const playAgainBtn = document.getElementById('hard-btn-play-again');
            if (playAgainBtn) playAgainBtn.onclick = () => { if (hardModal && hardModal.close) hardModal.close(); if (current) current.restart(); };
            return;
          }
          // Default modal for Easy/Medium
          elements.finalTime().textContent = timeToMMSS(secs);
          elements.finalScore().textContent = String(final);
          let streak = Number(localStorage.getItem('igh_streak') || '0');
          const last = localStorage.getItem('igh_streak_last');
          const today = todayYYYYMMDD();
          if (state.isDaily) {
            if (last && last !== today) streak += 1;
            if (!last) streak = 1;
            localStorage.setItem('igh_streak', String(streak));
            localStorage.setItem('igh_streak_last', today);
          }
          elements.finalStreak().textContent = String(streak || 0);
          Sound.win();
          elements.resultsModal().showModal();
        }
      };

      const createRuntimeState = ({ categoryKey, difficulty, timerEnabled, rand, originalWords, puzzle, isDaily }) => {
        const found = new Set();
        const foundView = new Set();
        const wordPlacements = {};
        for (const [w, pos] of puzzle.wordPlacements.entries()) wordPlacements[w] = pos;
        const hintsAllowed = difficulty === 'easy' ? 6 : difficulty === 'medium' ? 4 : 2;
        return { categoryKey, difficulty, timerEnabled, rand, originalWords, puzzle, wordPlacements, targetWordCount: originalWords.length, found, foundView, timerStart: 0, timerInterval: null, lastWordAt: 0, score: 0, combo: 0, hintsUsed: 0, hintsAllowed, lastTipIndex: -1, isDaily, coachTimer: null, hasShownCoachInitial: false, hasShownCoach10s: false, restart: () => { renderGame(current); } };
      };

      const renderGame = (state) => {
        const oldGrid = elements.grid();
        if (oldGrid) { const newGrid = oldGrid.cloneNode(false); oldGrid.parentNode.replaceChild(newGrid, oldGrid); }
        renderPuzzle(state.puzzle);
        renderWordList(state.originalWords, state.foundView);
        elements.progressCount().textContent = '0';
        elements.progressTotal().textContent = String(state.targetWordCount);
        elements.score().textContent = '0';
        elements.timer().textContent = '00:00';
        const badge = document.getElementById('difficulty-badge');
        if (badge) { badge.textContent = state.difficulty.charAt(0).toUpperCase() + state.difficulty.slice(1); }
        const catNameEl = document.getElementById('category-name');
        if (catNameEl) { catNameEl.textContent = CategoryNames[state.categoryKey] || state.categoryKey; }
        const tipsPanel = document.getElementById('tips-panel');
        if (tipsPanel) tipsPanel.innerHTML = '';
        if (state.timerEnabled) startTimer(state);
        attachSelectionHandlers({ ...state, foundView: state.found });
        wireHintAndRestart(state);
        // Toggle prize reminder visibility for Hard only
        const reminder = document.getElementById('prize-reminder');
        if (reminder) reminder.style.display = state.difficulty === 'hard' ? 'block' : 'none';
        // Coach popup: only schedule inactivity (no immediate popup)
        wireCoachClose();
        scheduleCoachInactivity(state);
      };

      const wireHintAndRestart = (state) => {
        const hintBtn = elements.hintBtn();
        const restartBtn = elements.restartBtn();
        const revealBtn = document.getElementById('btn-reveal');
        if (revealBtn) {
          // Enable Reveal All on Easy and Hard for simulation
          revealBtn.classList.toggle('hidden', !(state.difficulty === 'easy' || state.difficulty === 'hard'));
          revealBtn.onclick = () => {
            if (!(state.difficulty === 'easy' || state.difficulty === 'hard')) return;
            // Ensure totals reflect placed words
            const placedCount = Object.keys(state.wordPlacements).length;
            if (state.targetWordCount !== placedCount) {
              state.targetWordCount = placedCount;
              elements.progressTotal().textContent = String(placedCount);
            }
            // Reveal all words visually and mark them found
            for (const word of Object.keys(state.wordPlacements)) {
              if (state.found.has(word)) continue;
              state.found.add(word);
              const positions = state.wordPlacements[word] || [];
              positions.forEach(({ x, y }) => {
                const cell = elements.grid().querySelector(`button[data-x="${x}"][data-y="${y}"]`);
                if (cell) {
                  cell.classList.add('bg-brand','text-white','cell-found');
                  cell.classList.remove('cell-hover');
                  cell.classList.remove('cell-start');
                }
              });
            }
            elements.progressCount().textContent = String(state.found.size);
            // Update word list UI
            renderWordList(state.originalWords, state.found);
            // Trigger completion
            checkCompletion(state);
          };
        }
        const updateHintLabel = () => { const remaining = Math.max(0, (state.hintsAllowed ?? 2) - state.hintsUsed); hintBtn.textContent = `Hint (${remaining})`; };
        updateHintLabel();
        hintBtn.onclick = () => {
          if (state.hintsUsed >= (state.hintsAllowed ?? 2)) { liveAnnounce('No hints remaining'); return; }
          const remaining = state.originalWords.map(normalizeWord).filter((w) => !state.found.has(w));
          if (remaining.length === 0) return;
          const target = remaining[Math.floor(state.rand() * remaining.length)];
          state.hintsUsed += 1;
          updateHintLabel();
          state.combo = 0;
          const pos = state.wordPlacements[target][0];
          const cell = elements.grid().querySelector(`button[data-x="${pos.x}"][data-y="${pos.y}"]`);
          if (cell) { cell.classList.add('animate-pulse', 'ring-2', 'ring-brand'); setTimeout(() => cell.classList.remove('animate-pulse', 'ring-2', 'ring-brand'), 1500); }
        };
        restartBtn.onclick = async () => {
          try {
            // Reset coach on restart
            hideCoach();
            clearCoachTimer(current);
            if (current?.isDaily) { await startDailyChallengeFromHome(); }
            else if (current) { await startQuickPlay(current.categoryKey); }
          } catch (e) { console.error('Restart failed', e); }
        };
        const btnBack = document.getElementById('btn-back');
        if (btnBack) {
          btnBack.onclick = () => { hideCoach(); clearCoachTimer(current); stopTimerIfRunning(current); showHome(); };
        }
      };

      const generateSeedFromDateAndCategory = async (dateStr, categoryKey) => {
        const hex = await sha256Hex(`IGETHOUSE-${dateStr}-${categoryKey.toUpperCase()}`);
        return hexToUint32(hex);
      };

      // App wiring (no modules)
      const homeView = document.getElementById('view-home');
      const gameView = document.getElementById('view-game');
      const btnHome = document.getElementById('btn-home');
      const btnSettings = document.getElementById('btn-settings');
      const settingsDialog = document.getElementById('settings-dialog');
      const btnDaily = document.getElementById('btn-daily');
      const difficultySelect = document.getElementById('difficulty');
      const timerEnabledCheckbox = document.getElementById('timer-enabled');
      const soundEnabledCheckbox = document.getElementById('sound-enabled');

      const state = { difficulty: 'easy', timerEnabled: true, soundEnabled: false };
      let current = null;

      const showHome = () => { stopTimerIfRunning(current); homeView.classList.remove('hidden'); gameView.classList.add('hidden'); };
      const showGame = () => { homeView.classList.add('hidden'); gameView.classList.remove('hidden'); };
      btnHome.addEventListener('click', showHome);
      const btnBackGlobal = document.getElementById('btn-back');
      if (btnBackGlobal) { btnBackGlobal.addEventListener('click', () => { hideCoach(); clearCoachTimer(current); stopTimerIfRunning(current); showHome(); }); }
      btnSettings.addEventListener('click', () => settingsDialog.showModal());
      settingsDialog.addEventListener('close', () => {
        state.difficulty = difficultySelect.value;
        state.timerEnabled = !!timerEnabledCheckbox.checked;
        state.soundEnabled = !!soundEnabledCheckbox.checked;
        try { localStorage.setItem('igh_settings', JSON.stringify(state)); } catch {}
      });

      const loadSettingsFromStorage = () => {
        try { const raw = localStorage.getItem('igh_settings'); if (!raw) return; const stored = JSON.parse(raw); if (stored.difficulty) state.difficulty = stored.difficulty; if (typeof stored.timerEnabled === 'boolean') state.timerEnabled = stored.timerEnabled; if (typeof stored.soundEnabled === 'boolean') state.soundEnabled = stored.soundEnabled; } catch {}
      };
      const syncSettingsUI = () => { difficultySelect.value = state.difficulty; timerEnabledCheckbox.checked = state.timerEnabled; soundEnabledCheckbox.checked = state.soundEnabled; };

      const startQuickPlay = async (categoryKey) => {
        const wordsBank = Words;
        const cfg = DifficultyConfig[state.difficulty];
        let display = [];
        let puzzle = null;
        let tries = 0;
        while (tries < 5) {
          const seed = ((Date.now() & 0xffffffff) ^ Math.floor(Math.random() * 0xffffffff) ^ tries) >>> 0;
          const rand = createRng(seed);
          const picked = sampleWordsForDifficulty(wordsBank[categoryKey] || [], state.difficulty, rand);
          puzzle = buildPuzzle(picked, state.difficulty, rand);
          const placedSet = new Set(Array.from(puzzle.wordPlacements.keys()));
          display = picked.filter((w) => placedSet.has(normalizeWord(w)));
          if (display.length >= Math.max(2, Math.min(cfg.wordsMin, 5))) break;
          tries++;
        }
        const seedFinal = ((Date.now() & 0xffffffff) ^ 0xabc123 ^ tries) >>> 0;
        const randFinal = createRng(seedFinal);
        current = createRuntimeState({ categoryKey, difficulty: state.difficulty, timerEnabled: state.timerEnabled, rand: randFinal, originalWords: display, puzzle, isDaily: false });
        renderGame(current);
        // Ensure coach popup is scheduled and shown even if initial hook missed
        wireCoachClose();
        triggerCoachOnLaunch(current);
        scheduleCoachInactivity(current);
      };

      const startDailyChallengeFromHome = async () => {
        const wordsBank = Words;
        let categories = Object.keys(wordsBank || {});
        if (!categories || categories.length === 0) categories = ['propertyTypes'];
        const today = todayYYYYMMDD();
        let categoryKey = 'propertyTypes';
        try { const seedForCategory = await generateSeedFromDateAndCategory(today, 'CATEGORY'); const randForCategory = createRng(seedForCategory); categoryKey = categories[Math.floor(randForCategory() * categories.length)] || 'propertyTypes'; } catch { categoryKey = 'propertyTypes'; }
        let display = [];
        let puzzle = null;
        let tries = 0;
        const cfg = DifficultyConfig[state.difficulty];
        while (tries < 5) {
          let seed = 1; try { seed = await generateSeedFromDateAndCategory(today, categoryKey + ':' + tries); } catch { seed = ((Date.now() & 0xffffffff) ^ 0x9e3779b9 ^ tries) >>> 0; }
          const rand = createRng(seed);
          const picked = sampleWordsForDifficulty(wordsBank[categoryKey] || [], state.difficulty, rand);
          puzzle = buildPuzzle(picked, state.difficulty, rand);
          const placedSet = new Set(Array.from(puzzle.wordPlacements.keys()));
          display = picked.filter((w) => placedSet.has(normalizeWord(w)));
          if (display.length >= Math.max(2, Math.min(cfg.wordsMin, 5))) break;
          tries++;
        }
        const seedFinal = ((Date.now() & 0xffffffff) ^ 0xdef456 ^ tries) >>> 0;
        const randFinal = createRng(seedFinal);
        current = createRuntimeState({ categoryKey, difficulty: state.difficulty, timerEnabled: state.timerEnabled, rand: randFinal, originalWords: display, puzzle, isDaily: true });
        renderGame(current);
        // Ensure coach popup is scheduled and shown even if initial hook missed
        wireCoachClose();
        triggerCoachOnLaunch(current);
        scheduleCoachInactivity(current);
      };

      btnDaily.addEventListener('click', async () => {
        try { btnDaily.disabled = true; showGame(); await startDailyChallengeFromHome(); } catch (err) { console.error('Failed to start Daily Challenge:', err); alert('Failed to start Daily Challenge.'); } finally { btnDaily.disabled = false; }
      });

      window.addEventListener('DOMContentLoaded', async () => {
        loadSettingsFromStorage();
        // Force default to Easy on each load per requirement
        try { state.difficulty = 'easy'; if (typeof difficultySelect !== 'undefined') difficultySelect.value = 'easy'; } catch {}
        syncSettingsUI();
        await loadCategories(async (category) => { showGame(); await startQuickPlay(category); });
        // Wire prizes dialog behavior
        const prizesDialog = document.getElementById('prizes-dialog');
        const btnPrizeHard = document.getElementById('btn-prize-hard');
        const btnPrizeEasy = document.getElementById('btn-prize-easy');
        window.openPrizesDialog = ({ categoryKey = '', startOnChoice = false } = {}) => {
          if (!prizesDialog) return;
          prizesDialog.dataset.categoryKey = categoryKey || '';
          prizesDialog.dataset.start = startOnChoice ? '1' : '0';
          try { prizesDialog.showModal(); } catch {}
        };
        if (btnPrizeHard) btnPrizeHard.onclick = async () => {
          try {
            if (prizesDialog) prizesDialog.close();
            state.difficulty = 'hard';
            if (typeof difficultySelect !== 'undefined') difficultySelect.value = 'hard';
            if (prizesDialog && prizesDialog.dataset.start === '1') {
              const cat = prizesDialog.dataset.categoryKey;
              if (cat) { showGame(); await startQuickPlay(cat); }
            }
          } catch {}
        };
        if (btnPrizeEasy) btnPrizeEasy.onclick = async () => {
          try {
            if (prizesDialog) prizesDialog.close();
            state.difficulty = 'easy';
            if (typeof difficultySelect !== 'undefined') difficultySelect.value = 'easy';
            if (prizesDialog && prizesDialog.dataset.start === '1') {
              const cat = prizesDialog.dataset.categoryKey;
              if (cat) { showGame(); await startQuickPlay(cat); }
            }
          } catch {}
        };
        // Show popup on load
        if (typeof openPrizesDialog === 'function') openPrizesDialog({ startOnChoice: false });
        // Wire result modal CTAs to external links
        const winCta1 = document.getElementById('win-cta-1');
        const winCta2 = document.getElementById('win-cta-2');
        if (winCta1) { winCta1.onclick = () => { window.open(BrandLinks.listingsLagos, '_blank'); }; }
        if (winCta2) { winCta2.onclick = () => { window.open(BrandLinks.nhfInfo, '_blank'); }; }
        const winCta3 = document.getElementById('win-cta-3');
        if (winCta3) { winCta3.onclick = () => { window.open(BrandLinks.whatsapp, '_blank'); }; }
        // Wire hard modal static elements if needed later
        const hardClaim = document.getElementById('hard-claim-wa');
        if (hardClaim) hardClaim.onclick = () => { window.open(BrandLinks.whatsapp, '_blank'); };
      });
    </script>
  </body>
</html> 